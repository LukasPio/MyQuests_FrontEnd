"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.handleDenyButtonClick=exports.handleConfirmButtonClick=exports.handleCancelButtonClick=void 0;var _close=require("./instanceMethods/close.js");var _privateProps=_interopRequireDefault(require("./privateProps.js"));var _showLoading=require("./staticMethods/showLoading.js");var _DismissReason=require("./utils/DismissReason.js");var _domUtils=require("./utils/dom/domUtils.js");var _getters=require("./utils/dom/getters.js");var _inputUtils=require("./utils/dom/inputUtils.js");var _utils=require("./utils/utils.js");var _this=void 0;function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{"default":obj}}/**
 * @param {SweetAlert} instance
 */var handleConfirmButtonClick=exports.handleConfirmButtonClick=function handleConfirmButtonClick(instance){var innerParams=_privateProps["default"].innerParams.get(instance);instance.disableButtons();if(innerParams.input){handleConfirmOrDenyWithInput(instance,"confirm")}else{confirm(instance,true)}};/**
 * @param {SweetAlert} instance
 */var handleDenyButtonClick=exports.handleDenyButtonClick=function handleDenyButtonClick(instance){var innerParams=_privateProps["default"].innerParams.get(instance);instance.disableButtons();if(innerParams.returnInputValueOnDeny){handleConfirmOrDenyWithInput(instance,"deny")}else{deny(instance,false)}};/**
 * @param {SweetAlert} instance
 * @param {Function} dismissWith
 */var handleCancelButtonClick=exports.handleCancelButtonClick=function handleCancelButtonClick(instance,dismissWith){instance.disableButtons();dismissWith(_DismissReason.DismissReason.cancel)};/**
 * @param {SweetAlert} instance
 * @param {'confirm' | 'deny'} type
 */var handleConfirmOrDenyWithInput=function handleConfirmOrDenyWithInput(instance,type){var innerParams=_privateProps["default"].innerParams.get(instance);if(!innerParams.input){(0,_utils.error)("The \"input\" parameter is needed to be set when using returnInputValueOn".concat((0,_utils.capitalizeFirstLetter)(type)));return}var input=instance.getInput();var inputValue=(0,_inputUtils.getInputValue)(instance,innerParams);if(innerParams.inputValidator){handleInputValidator(instance,inputValue,type)}else if(input&&!input.checkValidity()){instance.enableButtons();instance.showValidationMessage(innerParams.validationMessage||input.validationMessage)}else if(type==="deny"){deny(instance,inputValue)}else{confirm(instance,inputValue)}};/**
 * @param {SweetAlert} instance
 * @param {SweetAlertInputValue} inputValue
 * @param {'confirm' | 'deny'} type
 */var handleInputValidator=function handleInputValidator(instance,inputValue,type){var innerParams=_privateProps["default"].innerParams.get(instance);instance.disableInput();var validationPromise=Promise.resolve().then(function(){return(0,_utils.asPromise)(innerParams.inputValidator(inputValue,innerParams.validationMessage))});validationPromise.then(function(validationMessage){instance.enableButtons();instance.enableInput();if(validationMessage){instance.showValidationMessage(validationMessage)}else if(type==="deny"){deny(instance,inputValue)}else{confirm(instance,inputValue)}})};/**
 * @param {SweetAlert} instance
 * @param {any} value
 */var deny=function deny(instance,value){var innerParams=_privateProps["default"].innerParams.get(instance||_this);if(innerParams.showLoaderOnDeny){(0,_showLoading.showLoading)((0,_getters.getDenyButton)())}if(innerParams.preDeny){instance.isAwaitingPromise=true;// Flagging the instance as awaiting a promise so it's own promise's reject/resolve methods doesn't get destroyed until the result from this preDeny's promise is received
var preDenyPromise=Promise.resolve().then(function(){return(0,_utils.asPromise)(innerParams.preDeny(value,innerParams.validationMessage))});preDenyPromise.then(function(preDenyValue){if(preDenyValue===false){instance.hideLoading();(0,_close.handleAwaitingPromise)(instance)}else{instance.close({isDenied:true,value:typeof preDenyValue==="undefined"?value:preDenyValue})}})["catch"](function(error){return rejectWith(instance||_this,error)})}else{instance.close({isDenied:true,value:value})}};/**
 * @param {SweetAlert} instance
 * @param {any} value
 */var succeedWith=function succeedWith(instance,value){instance.close({isConfirmed:true,value:value})};/**
 *
 * @param {SweetAlert} instance
 * @param {string} error
 */var rejectWith=function rejectWith(instance,error){instance.rejectPromise(error)};/**
 *
 * @param {SweetAlert} instance
 * @param {any} value
 */var confirm=function confirm(instance,value){var innerParams=_privateProps["default"].innerParams.get(instance||_this);if(innerParams.showLoaderOnConfirm){(0,_showLoading.showLoading)()}if(innerParams.preConfirm){instance.resetValidationMessage();instance.isAwaitingPromise=true;// Flagging the instance as awaiting a promise so it's own promise's reject/resolve methods doesn't get destroyed until the result from this preConfirm's promise is received
var preConfirmPromise=Promise.resolve().then(function(){return(0,_utils.asPromise)(innerParams.preConfirm(value,innerParams.validationMessage))});preConfirmPromise.then(function(preConfirmValue){if((0,_domUtils.isVisible)((0,_getters.getValidationMessage)())||preConfirmValue===false){instance.hideLoading();(0,_close.handleAwaitingPromise)(instance)}else{succeedWith(instance,typeof preConfirmValue==="undefined"?value:preConfirmValue)}})["catch"](function(error){return rejectWith(instance||_this,error)})}else{succeedWith(instance,value)}};