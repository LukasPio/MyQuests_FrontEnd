"use strict";function _typeof(o){"@babel/helpers - typeof";return _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(o){return typeof o}:function(o){return o&&"function"==typeof Symbol&&o.constructor===Symbol&&o!==Symbol.prototype?"symbol":typeof o},_typeof(o)}Object.defineProperty(exports,"__esModule",{value:true});exports.closeToast=exports.closeModal=exports.closePopup=exports.close=close;exports.handleAwaitingPromise=void 0;exports.rejectPromise=rejectPromise;var _globalState=_interopRequireWildcard(require("../globalState.js"));var _keydownHandler=require("../keydown-handler.js");var _privateMethods=_interopRequireDefault(require("../privateMethods.js"));var _privateProps=_interopRequireDefault(require("../privateProps.js"));var _aria=require("../utils/aria.js");var _classes=require("../utils/classes.js");var dom=_interopRequireWildcard(require("../utils/dom/index.js"));var _iosFix=require("../utils/iosFix.js");var _scrollbar=require("../utils/scrollbar.js");function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{"default":obj}}function _getRequireWildcardCache(e){if("function"!=typeof WeakMap)return null;var r=new WeakMap,t=new WeakMap;return(_getRequireWildcardCache=function _getRequireWildcardCache(e){return e?t:r})(e)}function _interopRequireWildcard(e,r){if(!r&&e&&e.__esModule)return e;if(null===e||"object"!=_typeof(e)&&"function"!=typeof e)return{"default":e};var t=_getRequireWildcardCache(r);if(t&&t.has(e))return t.get(e);var n={__proto__:null},a=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var u in e)if("default"!==u&&Object.prototype.hasOwnProperty.call(e,u)){var i=a?Object.getOwnPropertyDescriptor(e,u):null;i&&(i.get||i.set)?Object.defineProperty(n,u,i):n[u]=e[u]}return n["default"]=e,t&&t.set(e,n),n}/**
 * @param {SweetAlert} instance
 * @param {HTMLElement} container
 * @param {boolean} returnFocus
 * @param {Function} didClose
 */function removePopupAndResetState(instance,container,returnFocus,didClose){if(dom.isToast()){triggerDidCloseAndDispose(instance,didClose)}else{(0,_globalState.restoreActiveElement)(returnFocus).then(function(){return triggerDidCloseAndDispose(instance,didClose)});(0,_keydownHandler.removeKeydownHandler)(_globalState["default"])}// workaround for https://github.com/sweetalert2/sweetalert2/issues/2088
// for some reason removing the container in Safari will scroll the document to bottom
if(_iosFix.isSafariOrIOS){container.setAttribute("style","display:none !important");container.removeAttribute("class");container.innerHTML=""}else{container.remove()}if(dom.isModal()){(0,_scrollbar.undoReplaceScrollbarWithPadding)();(0,_iosFix.undoIOSfix)();(0,_aria.unsetAriaHidden)()}removeBodyClasses()}/**
 * Remove SweetAlert2 classes from body
 */function removeBodyClasses(){dom.removeClass([document.documentElement,document.body],[_classes.swalClasses.shown,_classes.swalClasses["height-auto"],_classes.swalClasses["no-backdrop"],_classes.swalClasses["toast-shown"]])}/**
 * Instance method to close sweetAlert
 *
 * @param {any} resolveValue
 */function close(resolveValue){resolveValue=prepareResolveValue(resolveValue);var swalPromiseResolve=_privateMethods["default"].swalPromiseResolve.get(this);var didClose=triggerClosePopup(this);if(this.isAwaitingPromise){// A swal awaiting for a promise (after a click on Confirm or Deny) cannot be dismissed anymore #2335
if(!resolveValue.isDismissed){handleAwaitingPromise(this);swalPromiseResolve(resolveValue)}}else if(didClose){// Resolve Swal promise
swalPromiseResolve(resolveValue)}}var triggerClosePopup=function triggerClosePopup(instance){var popup=dom.getPopup();if(!popup){return false}var innerParams=_privateProps["default"].innerParams.get(instance);if(!innerParams||dom.hasClass(popup,innerParams.hideClass.popup)){return false}dom.removeClass(popup,innerParams.showClass.popup);dom.addClass(popup,innerParams.hideClass.popup);var backdrop=dom.getContainer();dom.removeClass(backdrop,innerParams.showClass.backdrop);dom.addClass(backdrop,innerParams.hideClass.backdrop);handlePopupAnimation(instance,popup,innerParams);return true};/**
 * @param {any} error
 */function rejectPromise(error){var rejectPromise=_privateMethods["default"].swalPromiseReject.get(this);handleAwaitingPromise(this);if(rejectPromise){// Reject Swal promise
rejectPromise(error)}}/**
 * @param {SweetAlert} instance
 */var handleAwaitingPromise=exports.handleAwaitingPromise=function handleAwaitingPromise(instance){if(instance.isAwaitingPromise){delete instance.isAwaitingPromise;// The instance might have been previously partly destroyed, we must resume the destroy process in this case #2335
if(!_privateProps["default"].innerParams.get(instance)){instance._destroy()}}};/**
 * @param {any} resolveValue
 * @returns {SweetAlertResult}
 */var prepareResolveValue=function prepareResolveValue(resolveValue){// When user calls Swal.close()
if(typeof resolveValue==="undefined"){return{isConfirmed:false,isDenied:false,isDismissed:true}}return Object.assign({isConfirmed:false,isDenied:false,isDismissed:false},resolveValue)};/**
 * @param {SweetAlert} instance
 * @param {HTMLElement} popup
 * @param {SweetAlertOptions} innerParams
 */var handlePopupAnimation=function handlePopupAnimation(instance,popup,innerParams){var container=dom.getContainer();// If animation is supported, animate
var animationIsSupported=dom.animationEndEvent&&dom.hasCssAnimation(popup);if(typeof innerParams.willClose==="function"){innerParams.willClose(popup)}if(animationIsSupported){animatePopup(instance,popup,container,innerParams.returnFocus,innerParams.didClose)}else{// Otherwise, remove immediately
removePopupAndResetState(instance,container,innerParams.returnFocus,innerParams.didClose)}};/**
 * @param {SweetAlert} instance
 * @param {HTMLElement} popup
 * @param {HTMLElement} container
 * @param {boolean} returnFocus
 * @param {Function} didClose
 */var animatePopup=function animatePopup(instance,popup,container,returnFocus,didClose){if(!dom.animationEndEvent){return}_globalState["default"].swalCloseEventFinishedCallback=removePopupAndResetState.bind(null,instance,container,returnFocus,didClose);popup.addEventListener(dom.animationEndEvent,function(e){if(e.target===popup){_globalState["default"].swalCloseEventFinishedCallback();delete _globalState["default"].swalCloseEventFinishedCallback}})};/**
 * @param {SweetAlert} instance
 * @param {Function} didClose
 */var triggerDidCloseAndDispose=function triggerDidCloseAndDispose(instance,didClose){setTimeout(function(){if(typeof didClose==="function"){didClose.bind(instance.params)()}// instance might have been destroyed already
if(instance._destroy){instance._destroy()}})};